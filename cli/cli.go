// Code generated by go-swagger; DO NOT EDIT.

package cli

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"log"
	"os"
	"path"
	"strings"

	client "github.com/cybledev/odin-cli/odin_cli"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
	"github.com/spf13/viper"
)

var (
	// debug flag indicating that cli should output debug logs
	debug bool = false

	// config file location
	configFile string

	// dry run flag
	dryRun bool

	rawOutput bool

	defaultLimit *int64

	defaultQuery string = "*"

	// name of the executable
	exeName = "odin"

	configFileName = "config"

	configFileType = "yaml"

	configDir string

	userAgent = "odin-cli/1.0.0"

	apiVersionPrefix = "apiVersion"
)

// logDebugf writes debug log to stdout
func logDebugf(format string, v ...interface{}) {
	if !debug {
		return
	}
	log.Printf(format, v...)
}

// depth of recursion to construct model flags
var maxDepth int = 5

// makeClient constructs a client object
func makeClient(cmd *cobra.Command, args []string) (*client.ODINAPIs, error) {
	hostname := viper.GetString("hostname")
	viper.SetDefault("base-path", client.DefaultBasePath)
	// basePath := viper.GetString("base-path")
	scheme := viper.GetString("scheme")

	defaultLimit = new(int64)
	*defaultLimit = 1

	currBasePath := getRequestBasePath(args)
	r := httptransport.New(hostname, currBasePath, []string{scheme})
	r.SetDebug(debug)
	// set custom producer and consumer to use the default ones

	r.Consumers["application/json"] = runtime.JSONConsumer()

	r.Producers["application/json"] = runtime.JSONProducer()
	// warning: produces text/plain is not supported by go-swagger cli yet

	auth, err := makeAuthInfoWriter(cmd)
	if err != nil {
		return nil, err
	}
	r.DefaultAuthentication = auth

	appCli := client.New(r, strfmt.Default)
	logDebugf("Server url: %v://%v", scheme, hostname)

	return appCli, nil
}

// MakeRootCmd returns the root cmd
func MakeRootCmd() (*cobra.Command, error) {
	cobra.OnInitialize(initViperConfigs)
	cobra.EnableCommandSorting = false

	// Use executable name as the command name
	rootCmd := &cobra.Command{
		Args: cobra.NoArgs,
		Use: exeName,
		Example: `
Search for hosts and services:
	$ odin hosts search --request.query="services.port:443 AND asn.number:AS13335"

Search for certificates:
	$ odin certificate search --request.query="certificate.subject_alt_name.dns_names:'cloudflare.com' AND certificate.validity.not_after:'2024-09-20T18:19:24'"

Search exposed buckets:
	$ odin exposed-buckets search --request.query='provider: aws AND file_cat_count.src: [10 TO *]'

Search domain names (and store output to a file):
	$ odin dns search --request.domain="cloudflare.com" > cf_domains.txt

Query using request payload in a json file:
	$ odin hosts search --query="$(cat request.json)"
`,
	}

	rootCmd.Flags().SortFlags = false
	rootCmd.PersistentFlags().SortFlags = false

	suffix := `
ODIN's primary focus is to equip infosec teams with a precise depiction of the internet, enabling them to strengthen their security defences and proactively detect threats within their attack surface.

For more information about our offerings and services, visit https://odin.io`

	rootCmd.SetUsageTemplate(fmt.Sprintf("%s\n%s\n", rootCmd.UsageTemplate(), suffix))

	viper.SetDefault("hostname", client.DefaultHost)
	viper.SetDefault("scheme", client.DefaultSchemes[0])
	viper.SetDefault("base-path", client.DefaultBasePath)

	// configure debug flag
	// configure config location
	rootCmd.PersistentFlags().StringVar(&configFile, "config", "", "Config file path")
	// configure dry run flag
	rootCmd.PersistentFlags().BoolVar(&dryRun, "dry-run", false, "Do not send the request to server")

	rootCmd.PersistentFlags().BoolVar(&rawOutput, "raw-output", false, "Output raw json response")

	rootCmd.PersistentFlags().BoolVar(&debug, "debug", false, "enable debug mode")
	rootCmd.PersistentFlags().MarkHidden("debug")

	// register security flags
	if err := registerAuthInoWriterFlags(rootCmd); err != nil {
		return nil, err
	}

	c0, err := makeGroupOfOperationsHostsCmd()
	if err != nil {
		return nil, err
	}
	rootCmd.AddCommand(c0)

	// add all operation groups
	c1, err := makeGroupOfOperationsCertificateCmd()
	if err != nil {
		return nil, err
	}
	rootCmd.AddCommand(c1)

	c3, err := makeGroupOfOperationsExposedBucketsCmd()
	if err != nil {
		return nil, err
	}
	rootCmd.AddCommand(c3)

	c4, err := makeGroupOfOperationsExposedFilesCmd()
	if err != nil {
		return nil, err
	}
	rootCmd.AddCommand(c4)

	c2, err := makeGroupOfOperationsDomainCmd()
	if err != nil {
		return nil, err
	}
	rootCmd.AddCommand(c2)

	c5, err := makeGroupOfOperationsFieldsCmd()
	if err != nil {
		return nil, err
	}
	rootCmd.AddCommand(c5)

	c7, err := makeGroupOfOperationsCreditsCmd()
	if err != nil {
		return nil, err
	}
	rootCmd.AddCommand(c7)

	c6, err := makeGroupOfOperationsHealthCmd()
	if err != nil {
		return nil, err
	}
	rootCmd.AddCommand(c6)

	// register config file flags
	if err := registerConfigFlags(rootCmd); err != nil {
		return nil, err
	}

	// add cobra completion
	rootCmd.AddCommand(makeGenCompletionCmd())

	if debug {
		err := validateFlags(rootCmd)
		if err != nil {
			rootCmd.Println("error validating flags: ", err)
		}
	}
	return rootCmd, nil
}

// initViperConfigs initialize viper config using config file in '$HOME/.config/<cli name>/config.<json|yaml...>'
// currently hostname, scheme and auth tokens can be specified in this config file.
func initViperConfigs() {
	if configFile != "" {
		// use user specified config file location
		viper.SetConfigFile(configFile)
	} else {
		var err error

		// look for default config (OS-specific, e.g. ".config" on linux)
		configDir, err = os.UserConfigDir()
		if err != nil {
			// fallback and try finding the home directory.
			home, err := os.UserHomeDir()
			cobra.CheckErr(err)
			configDir = path.Join(home, ".config")
		}

		// Search config in the config directory with name of the CLI binary (without extension).
		configDir = path.Join(configDir, exeName)
		viper.SetConfigName(configFileName)
		viper.SetConfigType(configFileType)
		viper.AddConfigPath(configDir)

		logDebugf("Config directory: %v, has been set", configDir)
	}

	if err := viper.ReadInConfig(); err != nil {
		logDebugf("Error: loading config file: %v", err)
		return
	}
	logDebugf("Using config file: %v", viper.ConfigFileUsed())
}

func generateManPages(cmd *cobra.Command) error {
    header := &doc.GenManHeader{
        Title:   exeName,
        Section: "1",
    }
    return doc.GenManTree(cmd, header, "./man")
}

func generateMarkdownDocs(cmd *cobra.Command) error {
    return doc.GenMarkdownTree(cmd, "./docs")
}

func registerConfigFlags(cmd *cobra.Command) error {
	initCmd := &cobra.Command{
		Args: cobra.NoArgs,
		Use:   "init",
		Short: "Initialize the config file and api keys",
		RunE:  runInitConfig,
	}
	cmd.AddCommand(initCmd)
	return nil
}

func runInitConfig(cmd *cobra.Command, args []string) error {
	var apiKey string
	fmt.Print("Enter the API key: ")
	fmt.Scanln(&apiKey)

	viper.Set("X-API-Key", strings.TrimSpace(apiKey))

	filePath := path.Join(configDir, configFileName+"."+configFileType)
	err := os.MkdirAll(configDir, os.ModePerm)
	if err != nil {
		logDebugf("Error creating config file: %s", err)
	}
	err = viper.WriteConfigAs(filePath)
	if err != nil {
		logDebugf("Error writing config file: %s", err)
	}

	cmd.Println("config saved successfully, at: ", filePath)
	return nil
}

// registerAuthInoWriterFlags registers all flags needed to perform authentication
func registerAuthInoWriterFlags(cmd *cobra.Command) error {
	// X-API-Key
	cmd.PersistentFlags().String("X-API-Key", "", ``)
	if err := viper.BindPFlag("X-API-Key", cmd.PersistentFlags().Lookup("X-API-Key")); err != nil {
		return err
	}

	return nil
}

// makeAuthInfoWriter retrieves cmd flags and construct an auth info writer
func makeAuthInfoWriter(cmd *cobra.Command) (runtime.ClientAuthInfoWriter, error) {
	auths := []runtime.ClientAuthInfoWriter{}

	// X-API-Key
	if viper.IsSet("X-API-Key") {
		XAPIKeyKey := viper.GetString("X-API-Key")
		auths = append(auths, httptransport.APIKeyAuth("X-API-Key", "header", XAPIKeyKey))
	}

	if len(auths) == 0 {
		logDebugf("Warning: No auth params detected.")
		return nil, nil
	}

	auths = append(auths, httptransport.APIKeyAuth("User-Agent", "header", userAgent))

	// compose all auths together
	return httptransport.Compose(auths...), nil
} // makeGroupOfOperationsCertificateCmd returns a parent command to handle all operations with tag "certificate"
func makeGroupOfOperationsCertificateCmd() (*cobra.Command, error) {
	parent := &cobra.Command{
		Use:  "certificate",
		Short: `Search digital certificates associated with websites or online services`,
		Example: `odin certificate search --request.query="certificate.subject_alt_name.dns_names:'cloudflare.com' AND certificate.validity.not_after:'2024-09-20T18:19:24'"`,
	}

	sub0, err := makeOperationCertificateGetCertificatesHashCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub0)

	sub1, err := makeOperationCertificatePostCertificatesCountCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub1)

	sub2, err := makeOperationCertificatePostCertificatesScrollCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub2)

	sub3, err := makeOperationCertificatePostCertificatesScrollNextCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub3)

	sub4, err := makeOperationCertificatePostCertificatesSearchCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub4)

	sub5, err := makeOperationCertificatePostCertificatesSummaryCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub5)

	return parent, nil
} // makeGroupOfOperationsCreditsCmd returns a parent command to handle all operations with tag "credits"
func makeGroupOfOperationsCreditsCmd() (*cobra.Command, error) {
	parent := &cobra.Command{
		Use:  "credits",
		Short: `Get the account related remaining and used credits details`,
	}

	sub0, err := makeOperationCreditsGetCreditsUsageCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub0)

	return parent, nil
} // makeGroupOfOperationsDNSCmd returns a parent command to handle all operations with tag "dns"
func makeGroupOfOperationsDNSCmd() (*cobra.Command, error) {
	parent := &cobra.Command{
		Use:  "domain",
		Short: `Search domains/subdomains and whois details`,
		Example: `odin domain search --request.keyword="cloudflare"`,
	}

	sub1, err := makeOperationDNSPostDomainSearchCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub1)

	sub0, err := makeOperationDNSPostDomainCountCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub0)

	return parent, nil
} // makeGroupOfOperationsExposedBucketsCmd returns a parent command to handle all operations with tag "exposed-buckets"
func makeGroupOfOperationsExposedBucketsCmd() (*cobra.Command, error) {
	parent := &cobra.Command{
		Use:  "exposed-buckets",
		Short: "Search across millions of buckets exposed over the internet",
		Example: `odin exposed-buckets search --request.query='provider: aws AND file_cat_count.src: [10 TO *]'`,
	}

	sub1, err := makeOperationExposedBucketsPostExposedBucketsSearchCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub1)

	sub0, err := makeOperationExposedBucketsPostExposedBucketsCountCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub0)

	sub2, err := makeOperationExposedBucketsPostExposedBucketsSummaryCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub2)

	return parent, nil
} // makeGroupOfOperationsExposedFilesCmd returns a parent command to handle all operations with tag "exposed-files"
func makeGroupOfOperationsExposedFilesCmd() (*cobra.Command, error) {
	parent := &cobra.Command{
		Use:  "exposed-files",
		Short: `Search across all the exposed files over the internet`,
		Example: `odin exposed-files search --request.query='provider: aws AND name: prod AND ext: ".db"'`,
	}

	sub1, err := makeOperationExposedFilesPostExposedFilesSearchCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub1)

	sub0, err := makeOperationExposedFilesPostExposedFilesCountCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub0)

	sub2, err := makeOperationExposedFilesPostExposedFilesSummaryCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub2)

	return parent, nil
} // makeGroupOfOperationsFieldsCmd returns a parent command to handle all operations with tag "fields"
func makeGroupOfOperationsFieldsCmd() (*cobra.Command, error) {
	parent := &cobra.Command{
		Use:  "fields",
		Short: `Get list of searchable fields`,
		Example: `
# get hosts categories
$ odin fields hosts --category=all

# get certificate categories
$ odin fields hosts --category=all

# get exposed items fields
$ odin fields exposed --category=files
$ odin fields exposed --category=buckets
`,
	}

	sub2, err := makeOperationFieldsGetFieldsHostsCategoryCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub2)

	sub3, err := makeOperationV2FieldsGetFieldsHostsCategoryCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub3)

	sub1, err := makeOperationFieldsGetFieldsCertificatesCategoryCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub1)

	sub0, err := makeOperationFieldsGetExposedCategoryCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub0)

	return parent, nil
} // makeGroupOfOperationsHealthCmd returns a parent command to handle all operations with tag "health"
func makeGroupOfOperationsHealthCmd() (*cobra.Command, error) {
	parent := &cobra.Command{
		Use:  "health",
		Short: `Get the status of the API server`,
	}

	sub0, err := makeOperationHealthGetPingCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub0)

	return parent, nil
} // makeGroupOfOperationsHostsCmd returns a parent command to handle all operations with tag "hosts"
func makeGroupOfOperationsHostsCmd() (*cobra.Command, error) {
	parent := &cobra.Command{
		Use:  "hosts",
		Short: `Search the list of hosts and their services (use v2 for optimized response)`,
		Example: `odin hosts search --request.query='services.port:443 AND asn.number:AS13335' --request.limit=1`,
	}

	sub5, err := makeOperationHostsPostHostsSearchCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub5)

	sub0, err := makeOperationHostsGetHostsCveIPCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub0)

	sub1, err := makeOperationHostsGetHostsExploitsIPCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub1)

	sub2, err := makeOperationHostsGetHostsIPCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub2)

	sub3, err := makeOperationHostsPostHostsCountCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub3)

	sub4, err := makeOperationHostsPostHostsFilteredSearchCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub4)

	sub6, err := makeOperationHostsPostHostsSummaryCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub6)

	sub11, err := makeOperationHostsPostV2HostsSearchCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub11)

	sub12, err := makeOperationHostsPostV2HostsSummaryCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub12)

	sub10, err := makeOperationHostsPostV2HostsIPCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub10)

	sub9, err := makeOperationHostsPostV2HostsCountCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub9)

	return parent, nil
}

func makeGroupOfOperationsDomainCmd() (*cobra.Command, error) {
	parent := &cobra.Command{
		Use:  "domain",
		Short: `search across domains, subdomains and whois data`,
		Example: `
$ odin domain search --request.keyword="cloudflare"
$ odin domain subdomain-search --request.domain="cloudflare.com"
$ odin domain whois --domain-name="cloudflare.com"
`,
	}

	sub1, err := makeOperationDNSPostDomainSearchCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub1)

	sub0, err := makeOperationDNSPostDomainCountCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub0)

	sub3, err := makeOperationDNSPostDomainSubdomainSearchCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub3)

	sub2, err := makeOperationDNSPostDomainSubdomainCountCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub2)

	sub4, err := makeOperationDomainWhoisGetDomainWhoisDomainNameCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub4)

	sub5, err := makeOperationDomainWhoisGetDomainWhoisDomainNameHistoricalCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub5)

	sub6, err := makeOperationDomainWhoisGetDomainWhoisDomainNameIsExpiredCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub6)

	sub7, err := makeOperationDomainWhoisGetDomainWhoisDomainNameIsRegisteredCmd()
	if err != nil {
		return nil, err
	}
	parent.AddCommand(sub7)

	return parent, nil
}

func getRequestBasePath(args []string) (basePath string) {
	for _, arg := range args {
		if strings.HasPrefix(arg, apiVersionPrefix) {
			splits := strings.Split(arg, apiVersionPrefix)
			if len(splits) > 0 {
				basePath = splits[1]
			}
		}
	}
	if basePath != "" {
		return basePath
	}
	return viper.GetString("base-path")
}